use hash_graph_rpc::specification;
use specta::TypeMap;

#[derive(specta::Type)]
struct X<const T: usize> {
    values: [u8; T],
}
#[derive(specta::Type)]
struct Example(X<3>);

#[allow(clippy::print_stdout)]
fn main() {
    println!("// This file is generated by `cargo run --example collect_types`");
    println!("// Do not edit this file directly");
    println!();
    println!("import {{Brand}} from 'ts-brand';");

    let mut types = TypeMap::default();

    let functions = specification::account::wasm::collect_types(&mut types);
    // ...add additional services here

    let config = specta::ts::ExportConfig::new();

    for (_, data_type) in types.iter() {
        let output =
            specta::ts::export_named_datatype(&config, data_type, &types).expect("exported");

        println!("{output}");
    }

    for function in functions {
        let mut output = String::new();

        if function.asyncness {
            output.push_str("async ");
        }

        output.push_str("function ");
        output.push_str(&function.name);
        output.push('(');

        for (index, (name, type_)) in function.args.iter().enumerate() {
            if index > 0 {
                output.push_str(", ");
            }

            output.push_str(name);
            output.push_str(": ");
            output.push_str(&specta::ts::datatype(&config, type_, &types).expect("datatype"));
        }

        let return_type =
            specta::ts::datatype(&config, &function.result, &types).expect("exported");

        output.push_str("): ");
        output.push_str(&return_type);
        output.push(';');

        println!("{output}");
    }
}
